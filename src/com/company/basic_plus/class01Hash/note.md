## Hash函数
1） in -> ∞， out -> s 

输入无限域，输出有限域
例如MD5，SHA1等,
两者都是十六进制，所以例如返回长度为16的字符串，那么能表示的范围就是0~16^16-1也就是0~2^64-1

2） same in -> same out

不随机，是个确定的函数，确定的规则

3） dif in -> same out

哈希碰撞，几率很低

4） 将输出均匀地离散分布到s有限域中

5） 在4）的情况下，把s有限结果域进行模运算 %m

可以将结果分布在 0~m-1 上均匀分布
即 in -f-> s -%m-> \[0~m-1\]


## HashMap
1） 为什么要扩容？

假设有17个桶，一共填了N个数据，（链地址法）平均每个桶需要查询 N/17 次，性能就达不到O(1)

2）何时扩容？

某条链长度大于8，或者数据个数到达3/4，就扩容到两倍原先容量。
每一个元素都重算一遍hash，再%m, m为新的容量，放到新的表里。

3）扩容代价？

增删改查代价:
- hash函数 O(1)
- 取模运算 O(1)
- 哈希碰撞，假设K长度的链，O(K)

扩容代价：

假设一共插入了N个字符串，则进行了 logN 次的扩容
如1000个字符串，一开始容量为2。

扩容过程： 2->4 ->8 ->16 ... -> 1024

``C * 2^K ≈ 1000。``（C为原始容量大小，K为扩容次数）

每次扩容，都要重新算一遍哈希值,则每次扩容时候的时间代价为 O(N)

所以：
总的扩容代价为 O(N*logN)
单次扩容代价为 O(logN)

4）扩容代价为O(logN)，那为什么使用的时候还说时间代价是O(1)? 

单次的增删时候，将C设置大一些，例如C为10，则O(logN)会是小常数，逼近O(1)，此时对于增删改查影响不大，仍然O(1)，但是极大地减小了扩容代价
虚拟机的离线扩容优化，不占用用户使用时间，进行扩容，扩容好后，用户直接使用新表。

每次增删改查的代价是O(1)，虽然每次扩容的代价是O(logN)，但是工程数据量非常低，而且有离线优化技术，所以说工程上认为是O(1)的时间复杂度。


## 布隆过滤器-去重神器(如黑名单、爬虫去重等)
1）只需要 增、查，可以不要删，非常省空间
2）只会误杀，不会漏杀，且可以设计得误杀的概率很低。

### 位图
bit[] 占用空间非常小。
例如100bit 只有 100/8 Byte

### 布隆过滤器
1)增

u1 --f1--> out1 --%m--> index1 把位图对应的格子描黑

u1 --f2--> out2 --%m--> index2 把位图对应的格子描黑

u1经过k个hash函数，最后得到≤k个描黑格子的位图。所有的u1~un都使用这个方法在位图上描黑。

2）查

如果加入过位图，一定计算结果位图相应格子都是黑色，即都是1。

由于hash函数是确定的，不会有漏杀的情况。
由于hash函数会有哈希碰撞，会有错杀情况。

3）失误率（与 描黑格子的比例、特征点采集碰撞概率 成正比）

位图容量m开的大小，开得太小失误率就高，最差情况全都描黑，谁都杀。
开得过大资源开销过多。

特征点个数（k个hash函数），太少，容易误杀，碰撞概率高。
太多，消耗位图格子，失误率增高。


4）公式

1. 确定是布隆过滤器模型
2. n = 样本量， p = 预期失误率 
> 注意,公式与url多长无关（即与元素大小无关）（因为哈希函数的输入可以无限域，只需要哈希函数能接受就行）
3. 计算理论需要多少空间，向上取整，且在允许范围内再稍大一些更好
> m = - n * lnP /(ln2)^2 （bit） ≈ - n * lnp / 0.49 （bit) 
4. 计算理论哈希函数的个数，向上取整
> K = ln2 * m / n ≈ 0.7 * m / n （个）
5. 计算真实失误率
> P真 = (1-e^(n*k真/m真))^k真


## 一致性哈希 - 数据均匀分布、负载均衡
1. hash的key要选择种类多，让高中低频都有较多数据。如男女，中美等都不合适。
2. 服务器分为：逻辑服务器、数据服务器。数据服务器一旦需要扩容，数据迁移的代价很大。
想让数据迁移代价减小，使用一致性哈希，不用取模运算，把哈希结果域想象成一个环。
数据服务器的host通过hash函数算出来结果，打在环上。完成数据迁移只需要拷贝一段数据给到新的服务器上。
3. 优点：数据迁移代价小
4. 存在问题：机器少的时候不一定均分，增减机器的时候不一定均分
5. 解决办法：虚拟节点
虚拟节点去抢环, m1(a1, a2 .... a1000) an就是虚拟节点。m1~m3,一共3000个虚拟节点抢环，按比例抢，虚拟节点多了，就均分了。
拷贝数据只需要把虚拟节点所管的数据交给另一个就可以了。
6. 妙用：管理负载
m1很强，可以给他更多的虚拟节点。根据实际机器的情况分配虚拟节点。
